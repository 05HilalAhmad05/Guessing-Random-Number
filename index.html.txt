<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Particle System (Mocked Gestures)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000011; color: white; font-family: sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            max-width: 300px;
        }
        #info h3 { margin-top: 0; }
        #info p { margin: 5px 0; }
    </style>
</head>
<body>

    <div id="info">
        <h3>Particle System Control (Mock Gestures)</h3>
        <p><strong>[1] FIREWORKS:</strong> Random explosion and gravity effect.</p>
        <p><strong>[2] HEART:</strong> Particles form a stable 2D shape.</p>
        <p><strong>[3] SATURN:</strong> Particles form a spinning ring.</p>
        <p><strong>[E] Toggle Expansion:</strong> Apply outward force to particles.</p>
        <hr>
        <p>Current Template: <strong id="current-template">FIREWORKS</strong></p>
        <p>Expansion Active: <strong id="is-expanding">FALSE</strong></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 30000;
        let GESTURE_FORCE_FACTOR = 0.5; // Controls expansion magnitude

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, geometry, particles;
        let positions, colors, velocities; 
        
        let gestureState = {
            isExpanding: false,
            targetTemplate: 'FIREWORKS' 
        };

        // --- CORE DATA ARRAYS ---
        // Stored outside the geometry for easy update access
        const velocitiesArray = [];
        const templateTargets = new Float32Array(PARTICLE_COUNT * 3); // To store the target x,y,z for HEART/SATURN shapes

        // --- INITIALIZATION ---
        function init() {
            // 1. Setup Scene, Camera, Renderer
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000011, 10, 100);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 2. Initialize Particle Geometry and Attributes
            const posArray = new Float32Array(PARTICLE_COUNT * 3);
            const colorArray = new Float32Array(PARTICLE_COUNT * 3);
            
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

            positions = geometry.attributes.position.array;
            colors = geometry.attributes.color.array;

            // 3. Populate Initial Data
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Initialize velocities (as Vector3 objects for easier math)
                velocitiesArray.push(new THREE.Vector3(0, 0, 0));
                
                // Initialize colors (for gradual transitions)
                colors[i * 3 + 0] = Math.random();
                colors[i * 3 + 1] = Math.random();
                colors[i * 3 + 2] = Math.random();
            }

            // 4. Create Material and Mesh (Points)
            const texture = createParticleTexture(); // Custom texture for a smoother look
            const material = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                map: texture,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Set initial template
            changeTemplate('FIREWORKS');
            
            // Start listeners and animation loop
            setupKeyboardControls();
            animate();
        }

        // --- UTILITY: Create a soft, circular texture for the particles ---
        function createParticleTexture() {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            
            const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(200, 200, 255, 1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            
            return new THREE.CanvasTexture(canvas);
        }

        // --- TEMPLATE LOGIC: Define particle targets/initial state ---
        function setTemplateTargets(template) {
            gestureState.targetTemplate = template;
            document.getElementById('current-template').textContent = template;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const v = velocitiesArray[i];

                // Reset velocities
                v.set(0, 0, 0); 
                
                switch (template) {
                    case 'FIREWORKS':
                        // Start at a central point with high initial velocity
                        positions[i3 + 0] = 0;
                        positions[i3 + 1] = 0;
                        positions[i3 + 2] = 0;
                        // Initial explosion velocity
                        v.set(Math.random() * 40 - 20, Math.random() * 40 - 20, Math.random() * 40 - 20);
                        break;

                    case 'HEART':
                        // Parametric curve for a heart shape
                        const t = i / PARTICLE_COUNT * (Math.PI * 2);
                        const radius = 10;
                        positions[i3 + 0] = radius * (16 * Math.sin(t) ** 3);
                        positions[i3 + 1] = -radius * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                        positions[i3 + 2] = (Math.random() - 0.5) * 2; // Slight depth variance
                        break;
                        
                    case 'SATURN':
                        // Create a ring (disk) shape
                        const theta = Math.random() * Math.PI * 2;
                        const r = Math.random() * 15 + 10;
                        positions[i3 + 0] = r * Math.cos(theta);
                        positions[i3 + 1] = (Math.random() - 0.5) * 1; // Flattened Y
                        positions[i3 + 2] = r * Math.sin(theta);
                        break;
                }
                
                // Set initial colors based on template
                colors[i3 + 0] = Math.random() * 0.8 + 0.2; 
                colors[i3 + 1] = template === 'HEART' ? 0.2 : Math.random() * 0.8 + 0.2; 
                colors[i3 + 2] = template === 'SATURN' ? 1.0 : Math.random() * 0.8 + 0.2;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.